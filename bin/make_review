#!/usr/bin/env bash
set -euo pipefail

# make_review
#
# 목적:
# - 특정 커밋(ref) 또는 범위(range)의 변경사항을 review로 생성합니다.
#
# 핵심 요구사항(반영됨):
# - review 파일 상단에 "commit 메시지(Subject+Body)"를 항상 포함
# - 파일명 앞에 timestamp prefix를 붙여 정렬/누적을 쉽게 함
# - 출력 저장 경로는 config(CODEX_REVIEW_OUT_DIR)로 변경 가능
#
# 사용 예:
#   make_review HEAD
#   make_review 9b59ee1
#   make_review b9e0c65..HEAD

load_config() {
  local cfg="${CODEX_REVIEW_CONFIG:-$HOME/.config/codex_review/config}"
  if [[ -f "$cfg" ]]; then
    # shellcheck disable=SC1090
    source "$cfg"
  fi
}

usage() {
  cat >&2 <<'EOF'
Usage: make_review <commit-sha|ref|range>

Examples:
  make_review 9b59ee1
  make_review HEAD
  make_review b9e0c65..HEAD
  make_review main...feature/my-branch

Output:
  Prints generated review file path to stdout.
EOF
}

sanitize_ref() {
  # 파일명에 쓰기 위험한 문자를 안전한 형태로 치환
  # - 브랜치명에 흔한 "/"는 경로로 해석되므로 "_"로 변경
  # - 공백도 "_"로 변경
  # - range 구분자인 "..." / ".."는 파일명에서 보기 쉬운 형태로 변경
  local ref="$1"
  ref="${ref//\//_}"
  ref="${ref// /_}"
  ref="${ref//.../___}"
  ref="${ref//../__}"
  printf '%s' "$ref"
}

is_range_ref() {
  # ".."가 들어가면 range로 취급(A..B 또는 A...B)
  [[ "$1" == *".."* ]]
}

validate_single_commit_ref() {
  # 단일 ref가 실제 커밋을 가리키는지 확인
  local ref="$1"
  if ! git rev-parse --verify "${ref}^{commit}" >/dev/null 2>&1; then
    echo "Error: ref '$ref' is not a valid commit." >&2
    exit 1
  fi
}

validate_range_ref() {
  # range(A..B / A...B)의 양 끝이 커밋으로 해석 가능한지 확인
  local ref="$1"
  local sep=".."
  if [[ "$ref" == *"..."* ]]; then
    sep="..."
  fi

  # bash parameter expansion으로 앞/뒤를 분리
  # - a: sep 이전
  # - b: sep 이후
  local a="${ref%%${sep}*}"
  local b="${ref#*${sep}}"

  if [[ -z "$a" || -z "$b" ]]; then
    echo "Error: invalid range '$ref' (expected A${sep}B)." >&2
    exit 1
  fi

  if ! git rev-parse --verify "${a}^{commit}" >/dev/null 2>&1; then
    echo "Error: range start '$a' is not a valid commit." >&2
    exit 1
  fi
  if ! git rev-parse --verify "${b}^{commit}" >/dev/null 2>&1; then
    echo "Error: range end '$b' is not a valid commit." >&2
    exit 1
  fi
}

print_commit_messages_single() {
  # 단일 커밋: subject + body
  local ref="$1"
  git show -s --format=$'%h %s%n%n%b' "$ref"
}

print_commit_messages_range() {
  # 범위 커밋: commit별 subject + body를 순서대로
  local ref="$1"
  git log --reverse --format=$'---%n%h %s%n%n%b%n' "$ref"
}

main() {
  load_config

  if [[ $# -ne 1 ]]; then
    usage
    exit 1
  fi

  local ref="$1"
  local safe_ref
  safe_ref="$(sanitize_ref "$ref")"

  # review 저장 폴더(기본 /tmp). 필요 시 config에서 변경 가능.
  local out_dir="${CODEX_REVIEW_OUT_DIR:-/tmp}"
  mkdir -p "$out_dir"

  # 파일명 정렬/누적을 위해 timestamp prefix 사용
  local ts
  ts="$(date +%Y%m%d_%H%M%S)"

  local out="${out_dir%/}/${ts}_review_${safe_ref}.txt"

  # range인지 단일 ref인지에 따라 생성 내용이 달라짐
  if is_range_ref "$ref"; then
    validate_range_ref "$ref"
    {
      echo "=== RANGE ==="
      echo "$ref"
      echo
      echo "=== COMMITS (subject + body) ==="
      print_commit_messages_range "$ref"
      echo
      echo "=== LOG (oneline) ==="
      git log --oneline --decorate --reverse "$ref"
      echo
      echo "=== STAT ==="
      git diff --stat "$ref"
      echo
      echo "=== DIFF ==="
      git diff "$ref"
    } > "$out"
  else
    validate_single_commit_ref "$ref"
    {
      echo "=== REF ==="
      echo "$ref"
      echo
      echo "=== COMMIT (subject + body) ==="
      print_commit_messages_single "$ref"
      echo
      echo "=== STAT ==="
      git show --stat --format= "$ref"
      echo
      echo "=== DIFF ==="
      git show --format= "$ref"
    } > "$out"
  fi

  # stdout에는 out 경로만 출력 (send_review가 이 값을 받아서 scp에 사용)
  echo "$out"
}

main "$@"
